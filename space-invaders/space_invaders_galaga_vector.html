<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Galaga 1981 - Arcade Clone</title>
    <style>
        body {
            background-color: #050505;
            color: #fff;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 30px rgba(0, 100, 255, 0.3);
            transform: scale(1);
        }

        canvas {
            background-color: #000;
            border: 4px solid #222;
            display: block;
            image-rendering: pixelated;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }
        .glow {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.7);
            pointer-events: none;
            z-index: 11;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: none;
        }

        .message-box {
            background: transparent;
            text-align: center;
            pointer-events: auto;
            display: none;
        }

        h1 { 
            margin: 0 0 10px 0; 
            color: #ff0000; 
            font-size: 48px;
            text-shadow: 4px 4px #00ffff; 
            letter-spacing: 5px;
        }
        
        h2 { color: #00ffff; font-size: 24px; margin-bottom: 30px; }

        .blink { animation: blinker 0.5s step-end infinite; }
        @keyframes blinker { 50% { opacity: 0; } }

        .btn {
            font-size: 24px;
            color: #ffff00;
            cursor: pointer;
            text-decoration: underline;
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 120px;
            z-index: 100;
            pointer-events: none;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .control-group {
            pointer-events: auto;
            display: flex;
            gap: 20px;
        }

        .touch-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 30px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .touch-btn:active, .touch-btn.active {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .d-pad-btn {
            border-radius: 10px;
            width: 70px;
            height: 70px;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="560" height="720"></canvas>
    <div class="scanlines"></div>
    <div class="glow"></div>
    
    <div id="ui-layer">
        <div id="startScreen" class="message-box" style="display: block;">
            <h1>GALAGA</h1>
            <p class="blink" style="color: #ff0000; font-size: 20px;">INSERT COIN</p>
            <br><br>
            <div id="startBtn" class="btn">PRESS START</div>
            <br>
            <p style="color: #aaa; font-size: 14px;">ARROWS to Move &bull; SPACE to Fire</p>
        </div>
        
        <div id="gameOverScreen" class="message-box">
            <h1 style="color:red">GAME OVER</h1>
            <h2 id="finalScore">SCORE: 0</h2>
            <p style="color: #fff">Hit Rate: <span id="hitRate">0</span>%</p>
            <br>
            <div id="restartBtn" class="btn blink">TRY AGAIN</div>
        </div>

        <div id="levelScreen" class="message-box">
            <h2 id="levelTitle" style="color:#00ffff">STAGE 1</h2>
        </div>
    </div>
</div>

<!-- Mobile Touch Controls -->
<div id="mobile-controls">
    <div class="control-group">
        <div class="touch-btn d-pad-btn" id="btnLeft">‚Üê</div>
        <div class="touch-btn d-pad-btn" id="btnRight">‚Üí</div>
    </div>
    <div class="control-group">
        <div class="touch-btn" id="btnFire">üî•</div>
    </div>
</div>

<script>
    /** 
     * GALAGA CLONE
     * Features: Bezier curve attacks, Dual Fighter mode, Starfield, "Bug" sprites.
     * UPDATE: Added Delta Time (dt) for framerate independence.
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- RENDER FUNCTIONS (Vector Graphics) ---
    
    function renderPlayer(ctx, x, y, w, h, color) {
        ctx.save();
        ctx.translate(x + w/2, y + h/2);
        
        // Glow
        ctx.shadowBlur = 10;
        ctx.shadowColor = color || '#0ff';
        
        // Main Body (Silver)
        ctx.fillStyle = '#ddd';
        ctx.beginPath();
        ctx.moveTo(0, -h/2);
        ctx.lineTo(w/2, h/2);
        ctx.lineTo(0, h/2 - 5);
        ctx.lineTo(-w/2, h/2);
        ctx.closePath();
        ctx.fill();
        
        // Cockpit (Red)
        ctx.fillStyle = '#f00';
        ctx.beginPath();
        ctx.arc(0, 0, w/6, 0, Math.PI * 2);
        ctx.fill();
        
        // Wings/Details (Cyan)
        ctx.fillStyle = color || '#0ff';
        ctx.fillRect(-w/2, h/4, w/4, h/4);
        ctx.fillRect(w/4, h/4, w/4, h/4);

        // Engine Trail
        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.moveTo(-4, h/2);
        ctx.lineTo(0, h/2 + 8);
        ctx.lineTo(4, h/2);
        ctx.fill();
        
        ctx.restore();
    }

    function renderEnemy(ctx, type, x, y, w, h, time) {
        ctx.save();
        ctx.translate(x + w/2, y + h/2);
        
        // Breathe/Pulse animation
        const pulse = Math.sin(time * 0.1) * 0.1 + 1;
        ctx.scale(pulse, pulse);

        if (type === 'bee') {
            // Wings
            ctx.fillStyle = 'rgba(100, 100, 255, 0.6)';
            ctx.beginPath();
            ctx.ellipse(-w/2, -h/4, w/2, h/3, -0.5, 0, Math.PI*2);
            ctx.ellipse(w/2, -h/4, w/2, h/3, 0.5, 0, Math.PI*2);
            ctx.fill();
            
            // Body (Yellow)
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.ellipse(0, 0, w/3, h/2, 0, 0, Math.PI*2);
            ctx.fill();
            
            // Stripes (Black)
            ctx.fillStyle = '#111';
            ctx.fillRect(-w/3, -h/6, w*0.66, h/6);
            ctx.fillRect(-w/3, h/6, w*0.66, h/6);
            
            // Eyes
            ctx.fillStyle = '#f00';
            ctx.fillRect(-6, -6, 4, 4);
            ctx.fillRect(2, -6, 4, 4);

        } else if (type === 'butterfly') {
            // Wings (Red/Orange)
            ctx.fillStyle = '#f40';
            ctx.beginPath();
            ctx.moveTo(0, h/2);
            ctx.lineTo(-w, -h/2);
            ctx.lineTo(0, -h/4);
            ctx.lineTo(w, -h/2);
            ctx.fill();
            
            // Body
            ctx.fillStyle = '#fff';
            ctx.fillRect(-2, -h/2, 4, h);

        } else if (type === 'boss') {
            // Green/Purple Alien
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#0f0';
            
            ctx.fillStyle = '#0a0';
            ctx.beginPath();
            ctx.moveTo(0, h/2);
            ctx.lineTo(w/2, -h/4);
            ctx.lineTo(0, -h/2);
            ctx.lineTo(-w/2, -h/4);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#a0a';
            ctx.beginPath();
            ctx.arc(0, -h/4, w/4, 0, Math.PI*2);
            ctx.fill();
        }
        
        ctx.restore();
    }

    // --- GAME STATE ---
    let state = {
        screen: 'START',
        level: 1,
        gameSpeed: 5,
        isFullWidth: false,
        score: 0,
        highScore: 20000,
        lives: 3,
        shotsFired: 0,
        shotsHit: 0,
        stars: [],
        player: null,
        enemies: [],
        bullets: [],
        enemyBullets: [],
        particles: [],
        frame: 0,
        active: false
    };

    // --- AUDIO CONTEXT ---
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    function playSound(type) {
        if(!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        const now = audioCtx.currentTime;
        
        if (type === 'shoot') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.linearRampToValueAtTime(800, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'explosion') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
        } else if (type === 'dive') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.linearRampToValueAtTime(300, now + 0.5);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        }
    }

    // --- UTILS ---
    function getBezierPoint(t, p0, p1, p2, p3) {
        const cX = 3 * (p1.x - p0.x);
        const bX = 3 * (p2.x - p1.x) - cX;
        const aX = p3.x - p0.x - cX - bX;
        const cY = 3 * (p1.y - p0.y);
        const bY = 3 * (p2.y - p1.y) - cY;
        const aY = p3.y - p0.y - cY - bY;
        const x = (aX * Math.pow(t, 3)) + (bX * Math.pow(t, 2)) + (cX * t) + p0.x;
        const y = (aY * Math.pow(t, 3)) + (bY * Math.pow(t, 2)) + (cY * t) + p0.y;
        return { x, y };
    }

    // --- CLASSES ---

    class Star {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.speed = Math.random() * 0.5 + 0.1; // Slower stars
            this.blink = Math.random() > 0.8;
        }
        update(dt) {
            this.y += this.speed * dt;
            if (this.y > canvas.height) {
                this.y = 0;
                this.x = Math.random() * canvas.width;
            }
        }
        draw() {
            ctx.fillStyle = this.blink && Math.random() > 0.9 ? '#000' : '#555';
            if (this.speed > 0.5) ctx.fillStyle = '#fff'; 
            ctx.fillRect(this.x, this.y, 2, 2);
        }
    }

    class Player {
        constructor() {
            this.width = 22; 
            this.height = 18;
            this.x = canvas.width / 2 - this.width;
            this.y = canvas.height - 50;
            this.speed = 3.5; // Slightly reduced base speed
            this.extraShips = 0;
            this.dead = false;
            this.cooldown = 0;
        }
        
        update(dt) {
            if (this.dead) return;
            // Normalize speed with dt
            const moveSpeed = this.speed * dt;
            let totalWidth = this.width + this.extraShips * 24;
            if (keys.ArrowLeft && this.x > 10) this.x -= moveSpeed;
            if (keys.ArrowRight && this.x < canvas.width - 10 - totalWidth) this.x += moveSpeed;

            // Shooting Logic
            if (this.cooldown > 0) this.cooldown -= 1 * dt;
            
            if (keys.Space && this.cooldown <= 0) {
                this.shoot();
                // Auto-fire (5 frames cooldown ~ 12 shots/sec)
                this.cooldown = 5;
            }
        }

        draw() {
            if (this.dead) return;
            for (let i = 0; i <= this.extraShips; i++) {
                renderPlayer(ctx, this.x + (i * 24), this.y, this.width, this.height);
            }
        }

        shoot() {
            if (this.dead) return;
            state.shotsFired++;
            playSound('shoot');
            for (let i = 0; i <= this.extraShips; i++) {
                state.bullets.push(new Bullet(this.x + 10 + (i * 24), this.y, -7, true));
            }
        }
        
        hit() {
            if (this.extraShips > 0) {
                createExplosion(this.x + this.extraShips * 24, this.y, '#f00');
                playSound('explosion');
                this.extraShips--;
            } else {
                this.dead = true;
                createExplosion(this.x, this.y, '#f00');
                playSound('explosion');
                setTimeout(() => {
                    handlePlayerDeath();
                }, 1500);
            }
        }
    }

    class Bullet {
        constructor(x, y, vy, isPlayer) {
            this.x = x; this.y = y; this.vy = vy;
            this.width = 4; this.height = 8;
            this.isPlayer = isPlayer;
            this.active = true;
        }
        update(dt) {
            this.y += this.vy * dt;
            if (this.y < -10 || this.y > canvas.height + 10) this.active = false;
        }
        draw() {
            ctx.save();
            ctx.shadowBlur = 5;
            ctx.shadowColor = this.isPlayer ? '#0ff' : '#f80';
            ctx.fillStyle = this.isPlayer ? '#0ff' : '#f80';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.restore();
        }
    }

    class Enemy {
        constructor(type, gridC, gridR, startX = 60) {
            this.type = type;
            this.gridX = startX + gridC * 40;
            this.gridY = 80 + gridR * 30;
            this.x = this.gridX;
            this.y = -50;
            this.width = 20; this.height = 16;
            
            this.state = 'IDLE';
            this.t = 0;
            this.hp = (type === 'boss') ? 2 : 1;
            
            this.pathStart = {x:0, y:0};
            this.pathEnd = {x:0, y:0};
            this.cp1 = {x:0, y:0};
            this.cp2 = {x:0, y:0};
            
            this.frameCount = 0;
        }

        update(dt) {
            this.frameCount += dt;
            
            // BONUS LEVEL LOGIC
            if (state.isBonusLevel) {
                // Figure-8 Pattern
                const time = this.frameCount * 0.02 + (this.bonusOffset || 0);
                const width = 150;
                const height = 60;
                
                // Center X based on canvas width
                const centerX = canvas.width / 2;
                const centerY = 250 + (this.gridY - 80); // Keep relative row positions
                
                // Lissajous figure (Figure 8)
                this.x = centerX + Math.sin(time) * width - 10; // -10 to center sprite
                this.y = centerY + Math.sin(time * 2) * height;
                return;
            }
            
            // Slower sway
            const sway = Math.sin(this.frameCount * 0.03) * 5;

            if (this.state === 'IDLE') {
                this.x = this.gridX + sway;
                this.y = this.gridY;
                
                // Attack chance normalized by dt and gameSpeed
                // Base chance 0.002. Speed 5 -> 1x. Speed 10 -> 2x.
                const speedFactor = state.gameSpeed / 5;
                if (!state.player.dead && Math.random() < (0.002 + (state.level * 0.001)) * dt * speedFactor) {
                    if (Math.random() < 0.7) {
                        this.startDive();
                    } else {
                        this.startCircle();
                    }
                }
            }
            else if (this.state === 'DIVING') {
                this.t += 0.012 * dt; // Normalized dive speed
                if (this.t >= 1) {
                    this.state = 'RETURNING';
                    this.t = 0;
                    this.pathStart = {x: this.x, y: this.y};
                    this.pathEnd = {x: this.gridX, y: this.gridY};
                    this.cp1 = {x: this.x, y: canvas.height + 50};
                    this.cp2 = {x: this.gridX, y: -50};
                } else {
                    const pos = getBezierPoint(this.t, this.pathStart, this.cp1, this.cp2, this.pathEnd);
                    this.x = pos.x;
                    this.y = pos.y;
                    
                    const speedFactor = state.gameSpeed / 5;
                    if (Math.random() < 0.03 * dt * speedFactor) {
                        state.enemyBullets.push(new Bullet(this.x + 8, this.y + 16, 4, false));
                    }
                }
            }
            else if (this.state === 'CIRCLING') {
                this.t += 0.05 * dt; // Circle speed
                const endAngle = -Math.PI / 2 + 2 * Math.PI;
                
                if (this.t >= endAngle) {
                    this.state = 'RETURNING';
                    this.t = 0;
                } else {
                    this.x = this.circleCenter.x + this.circleRadius * Math.cos(this.t);
                    this.y = this.circleCenter.y + this.circleRadius * Math.sin(this.t);
                    
                    // Shoot during circle
                    const speedFactor = state.gameSpeed / 5;
                    if (Math.random() < 0.02 * dt * speedFactor) {
                        state.enemyBullets.push(new Bullet(this.x + 8, this.y + 16, 4, false));
                    }
                }
            }
            else if (this.state === 'RETURNING') {
                // Lerp with dt correction (approximate)
                const factor = 0.05 * dt;
                this.x += (this.gridX + sway - this.x) * factor;
                this.y += (this.gridY - this.y) * factor;
                if (Math.abs(this.x - (this.gridX + sway)) < 2 && Math.abs(this.y - this.gridY) < 2) {
                    this.state = 'IDLE';
                }
            }
        }

        startDive() {
            // CRASH FIX: Ensure player exists
            if (!state.player || state.player.dead) return;

            this.state = 'DIVING';
            this.t = 0;
            this.pathStart = {x: this.x, y: this.y};
            
            const px = state.player.x;
            const py = state.player.y;
            
            const side = Math.random() > 0.5 ? 1 : -1;
            
            this.cp1 = {x: this.x + (100 * side), y: this.y + 100};
            this.cp2 = {x: px - (100 * side), y: py - 100};
            this.pathEnd = {x: px, y: canvas.height + 50};
            
            playSound('dive');
        }

        startCircle() {
            if (!state.player || state.player.dead) return;
            
            this.state = 'CIRCLING';
            this.circleRadius = 80;
            // Center is below the enemy so they swoop down
            this.circleCenter = { x: this.x, y: this.y + this.circleRadius };
            // Start at top of circle (-90 deg)
            this.t = -Math.PI / 2;
            
            playSound('dive');
        }

        draw() {
            renderEnemy(ctx, this.type, this.x, this.y, this.width, this.height, this.frameCount);
        }
    }

    function createExplosion(x, y, color) {
        for(let i=0; i<10; i++) {
            state.particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 6, // Slightly reduced
                vy: (Math.random() - 0.5) * 6,
                life: 30,
                color: color
            });
        }
    }

    // --- GAME LOGIC ---

    function initGame() {
        for(let i=0; i<50; i++) state.stars.push(new Star());
    }

    function startLevel(lvl) {
        state.level = lvl;
        state.isBonusLevel = (lvl % 2 === 0);
        state.enemies = [];
        state.bullets = [];
        state.enemyBullets = [];
        
        // Preserve Dual Fighter status if player exists
        const extraShips = state.player ? state.player.extraShips : 0;
        state.player = new Player();
        state.player.extraShips = extraShips;
        
        const layout = [
            'boss', 'butterfly', 'butterfly', 'bee', 'bee'
        ];
        
        // Center formation
        // 10 columns * 40 width = 400px wide formation
        const startX = (canvas.width - 400) / 2;

        for (let r = 0; r < 5; r++) {
            for (let c = 0; c < 10; c++) {
                // In Bonus Level, spawn full rows!
                if (!state.isBonusLevel && r===0 && (c<3 || c>6)) continue; 
                
                let enemy = new Enemy(layout[r], c, r, startX);
                
                if (state.isBonusLevel) {
                    // Initialize bonus movement params
                    enemy.bonusOffset = c * 0.2 + r * 0.5; // Stagger movement
                    enemy.y = 100 + r * 40; // Start lower
                }
                
                state.enemies.push(enemy);
            }
        }

        state.screen = 'LEVEL_INTRO';
        const ui = document.getElementById('levelScreen');
        document.getElementById('levelTitle').innerText = state.isBonusLevel ? "CHALLENGE STAGE" : `STAGE ${lvl}`;
        ui.style.display = 'block';
        
        setTimeout(() => {
            ui.style.display = 'none';
            state.screen = 'PLAYING';
        }, 2000);
    }

    function handlePlayerDeath() {
        state.lives--;
        if (state.lives <= 0) {
            state.screen = 'GAMEOVER';
            document.getElementById('gameOverScreen').style.display = 'block';
            document.getElementById('finalScore').innerText = `SCORE: ${state.score}`;
            const rate = state.shotsFired > 0 ? Math.round((state.shotsHit / state.shotsFired)*100) : 0;
            document.getElementById('hitRate').innerText = rate;
        } else {
            state.player = new Player();
            state.bullets = [];
            state.enemyBullets = [];
        }
    }

    function update(dt) {
        state.frame++;
        
        state.stars.forEach(s => s.update(dt));
        
        if (state.screen !== 'PLAYING') return;

        state.player.update(dt);

        state.enemies.forEach(e => e.update(dt));

        state.bullets.forEach((b, i) => {
            b.update(dt);
            if (b.active) {
                state.enemies.forEach(e => {
                    if (b.x < e.x + e.width && b.x + b.width > e.x &&
                        b.y < e.y + e.height && b.y + b.height > e.y) {
                        b.active = false;
                        state.shotsHit++;
                        e.hp--;
                        if (e.hp <= 0) {
                            createExplosion(e.x, e.y, e.type === 'boss' ? '#0f0' : '#ff0');
                            playSound('explosion');
                            
                            if(e.type === 'bee') state.score += 50;
                            if(e.type === 'butterfly') state.score += 80;
                            if(e.type === 'boss') state.score += 150;
                            
                            if (e.type === 'boss' && !state.player.dual && Math.random() < 0.3) {
                                state.enemyBullets.push({
                                    x: e.x, y: e.y, width: 16, height: 16, vy: 2.5, // Slower drop
                                    isPowerup: true, active: true
                                });
                            }
                        }
                    }
                });
            }
        });
        
        state.enemyBullets.forEach(b => {
            if (b.isPowerup) {
                b.y += b.vy * dt;
                if(b.y > canvas.height) b.active = false;
                if (b.active && state.player && !state.player.dead &&
                    b.x < state.player.x + (state.player.width + state.player.extraShips * 24) && b.x + b.width > state.player.x &&
                    b.y < state.player.y + state.player.height && b.y + b.height > state.player.y) {
                    
                    b.active = false;
                    
                    if (state.player.extraShips < 4) state.player.extraShips++;
                    
                    // Play powerup sound
                }
            } else {
                b.update(dt);
                if (b.active && state.player && !state.player.dead &&
                    b.x < state.player.x + (state.player.width + state.player.extraShips * 24) && b.x + b.width > state.player.x &&
                    b.y < state.player.y + state.player.height && b.y + b.height > state.player.y) {
                    b.active = false;
                    state.player.hit();
                }
            }
        });

        state.bullets = state.bullets.filter(b => b.active);
        state.enemyBullets = state.enemyBullets.filter(b => b.active);
        state.enemies = state.enemies.filter(e => e.hp > 0);
        
        state.particles.forEach(p => {
            p.x += p.vx * dt; p.y += p.vy * dt; 
            p.life -= 1 * dt;
        });
        state.particles = state.particles.filter(p => p.life > 0);

        if (state.enemies.length === 0) {
            startLevel(state.level + 1);
        }
    }

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        state.stars.forEach(s => s.draw());

        if (state.screen === 'PLAYING' || state.screen === 'LEVEL_INTRO' || state.screen === 'GAMEOVER') {
            if (state.player) state.player.draw();
            state.enemies.forEach(e => e.draw());
            
            state.bullets.forEach(b => b.draw());
            
            state.enemyBullets.forEach(b => {
                if (b.isPowerup) {
                    renderPlayer(ctx, b.x, b.y, b.width, b.height, '#0f0');
                } else {
                    ctx.save();
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#f00';
                    ctx.fillStyle = '#f00';
                    ctx.fillRect(b.x, b.y, b.width, b.height);
                    ctx.restore();
                }
            });

            state.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = Math.max(0, p.life / 30);
                ctx.fillRect(p.x, p.y, 3, 3);
            });
            ctx.globalAlpha = 1;

            ctx.fillStyle = '#fff';
            ctx.font = '20px "Courier New"';
            ctx.fillText(`SCORE: ${state.score}`, 20, 30);
            ctx.fillText(`HIGH: ${state.highScore}`, 200, 30);
            ctx.fillText(`SPEED: ${state.gameSpeed}`, 380, 30);
            
            for(let i=0; i<state.lives-1; i++) {
                renderPlayer(ctx, 20 + (i*30), canvas.height - 30, 20, 15);
            }
        }
    }

    // --- RESIZE LOGIC ---
    function handleResize() {
        const isFull = document.fullscreenElement != null;
        if (state.isFullWidth === isFull) return; // Avoid redundant resizes

        state.isFullWidth = isFull;
        const oldW = canvas.width;
        canvas.width = state.isFullWidth ? 1120 : 560;
        const diff = (canvas.width - oldW) / 2;

        // Reposition game elements
        if (state.player) state.player.x += diff;
        state.enemies.forEach(en => {
            if (en.gridX) en.gridX += diff;
            if(en.pathStart) en.pathStart.x += diff;
            if(en.pathEnd) en.pathEnd.x += diff;
            if(en.cp1) en.cp1.x += diff;
            if(en.cp2) en.cp2.x += diff;
            if(en.circleCenter) en.circleCenter.x += diff;
            en.x += diff;
        });
        state.bullets.forEach(b => b.x += diff);
        state.enemyBullets.forEach(b => b.x += diff);
        state.stars = [];
        initGame(); // Re-creates stars for the new width
    }
    document.addEventListener('fullscreenchange', handleResize);
    
    // Set initial size on load
    document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
            if (localStorage.getItem('fullscreen-state') === 'true' && document.fullscreenElement) {
                handleResize();
            }
        }, 200);
    });

    // --- INPUT ---
    const keys = { ArrowLeft: false, ArrowRight: false, Space: false, Control: false };

    function handleEscape() {
        if (state.screen === 'PLAYING' || state.screen === 'GAMEOVER' || state.screen === 'LEVEL_INTRO') {
            state.screen = 'START';
            document.getElementById('startScreen').style.display = 'block';
            document.getElementById('gameOverScreen').style.display = 'none';
            const levelScreen = document.getElementById('levelScreen');
            if (levelScreen) levelScreen.style.display = 'none';

            // Reset game entities
            state.enemies = [];
            state.bullets = [];
            state.enemyBullets = [];
            state.particles = [];
            state.player = null;
        } else if (state.screen === 'START') {
            window.location.href = '../index.html';
        }
    }

    window.addEventListener('keydown', (e) => {
        if(e.code === 'ArrowLeft') keys.ArrowLeft = true;
        if(e.code === 'ArrowRight') keys.ArrowRight = true;
        if(e.key === 'Control' || e.code === 'ControlLeft' || e.code === 'ControlRight') keys.Control = true;
        
        // Speed Control
        if (e.key >= '1' && e.key <= '9') state.gameSpeed = parseInt(e.key);
        if (e.key === '0') state.gameSpeed = 10;
        
        if (e.code === 'Escape') {
            e.preventDefault();
            handleEscape();
        }

        if(e.code === 'Space') {
            if (state.screen === 'START') {
                initAudio();
                initGame();
                state.score = 0; state.lives = 3;
                document.getElementById('startScreen').style.display = 'none';
                startLevel(1);
            } else if (state.screen === 'GAMEOVER') {
                document.getElementById('gameOverScreen').style.display = 'none';
                state.score = 0; state.lives = 3;
                startLevel(1);
            }
            // Playing state shooting is now handled in Player.update
            keys.Space = true;
        }
    });

    window.addEventListener('keyup', (e) => {
        if(e.code === 'ArrowLeft') keys.ArrowLeft = false;
        if(e.code === 'ArrowRight') keys.ArrowRight = false;
        if(e.code === 'Space') keys.Space = false;
        if(e.key === 'Control' || e.code === 'ControlLeft' || e.code === 'ControlRight') keys.Control = false;
    });

    // Button clicks
    document.getElementById('startBtn').addEventListener('click', () => {
        initAudio(); initGame();
        document.getElementById('startScreen').style.display = 'none';
        state.score = 0; state.lives = 3;
        startLevel(1);
    });
    document.getElementById('restartBtn').addEventListener('click', () => {
        document.getElementById('gameOverScreen').style.display = 'none';
        state.score = 0; state.lives = 3;
        startLevel(1);
    });

    // --- GAME LOOP WITH DELTA TIME ---
    let lastTime = 0;
    function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        // Cap dt to prevent spiraling if tab is inactive (max 100ms)
        // Normalize to target 60FPS (16.67ms) -> dt = 1.0 roughly
        const dt = (Math.min(deltaTime, 100) / 16.67) * (state.gameSpeed / 5);

        update(dt);
        draw();
        requestAnimationFrame(loop);
    }

    // Initial render
    initGame();
    loop(0); // Pass 0 initial timestamp

    // --- MOBILE CONTROLS ---
    function isMobile() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.maxTouchPoints > 0 && window.innerWidth <= 1024);
    }

    if (isMobile()) {
        // Auto-fullscreen on first interaction (touchend/click are safer for user gestures)
        const goFullscreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(() => {});
            }
        };
        document.addEventListener('touchend', goFullscreen, { passive: false });
        document.addEventListener('click', goFullscreen, { passive: false });

        // Swipe Down for Escape
        let touchStartY = 0;
        let touchStartX = 0;
        document.addEventListener('touchstart', e => {
            touchStartY = e.changedTouches[0].screenY;
            touchStartX = e.changedTouches[0].screenX;
        }, { passive: false });

        document.addEventListener('touchend', e => {
            const touchEndY = e.changedTouches[0].screenY;
            const touchEndX = e.changedTouches[0].screenX;
            
            if (touchEndY - touchStartY > 100 && Math.abs(touchEndX - touchStartX) < 100) {
                handleEscape();
            }
        }, { passive: false });

        const mobileControls = document.getElementById('mobile-controls');
        if (mobileControls) {
            mobileControls.style.display = 'flex';
            
            const setupBtn = (id, key) => {
                const btn = document.getElementById(id);
                if (!btn) return;
                
                const activate = (e) => {
                    e.preventDefault();
                    keys[key] = true;
                    btn.classList.add('active');
                    
                    if (key === 'Space' && state.screen === 'START') {
                        initAudio(); initGame(); state.score = 0; state.lives = 3; document.getElementById('startScreen').style.display = 'none'; startLevel(1);
                    }
                    if (key === 'Space' && state.screen === 'GAMEOVER') {
                        document.getElementById('gameOverScreen').style.display = 'none'; state.score = 0; state.lives = 3; startLevel(1);
                    }
                };

                const deactivate = (e) => {
                    e.preventDefault();
                    keys[key] = false;
                    btn.classList.remove('active');
                };

                btn.addEventListener('touchstart', activate, { passive: false });
                btn.addEventListener('touchend', deactivate, { passive: false });
                btn.addEventListener('touchcancel', deactivate, { passive: false });
                btn.addEventListener('mousedown', activate);
                btn.addEventListener('mouseup', deactivate);
                btn.addEventListener('mouseleave', deactivate);
            };

            setupBtn('btnLeft', 'ArrowLeft');
            setupBtn('btnRight', 'ArrowRight');
            setupBtn('btnFire', 'Space');
        }
    }
</script>
<script>
    const FULLSCREEN_KEY = 'fullscreen-state';

    function isFullscreen() {
        return document.fullscreenElement != null;
    }

    function enterFullscreen() {
        if (!isFullscreen()) {
            document.documentElement.requestFullscreen().catch(err => {
                // console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        }
    }

    function exitFullscreen() {
        if (isFullscreen()) {
            document.exitFullscreen();
        }
    }

    function handleFullscreenToggle() {
        if (isFullscreen()) {
            exitFullscreen();
        } else {
            enterFullscreen();
        }
    }

    // On page load, check the stored state
    document.addEventListener('DOMContentLoaded', () => {
        // We use a timeout to avoid issues where the browser isn't ready
        setTimeout(() => {
            if (localStorage.getItem(FULLSCREEN_KEY) === 'true' && !isFullscreen()) {
                enterFullscreen();
            }
             if (localStorage.getItem(FULLSCREEN_KEY) === 'false' && isFullscreen()) {
                exitFullscreen();
            }
        }, 150);
    });

    // When fullscreen state changes (e.g., user presses ESC, or through our function)
    document.addEventListener('fullscreenchange', () => {
        localStorage.setItem(FULLSCREEN_KEY, isFullscreen() ? 'true' : 'false');
    });

    // Listen for the F key
    window.addEventListener('keydown', (e) => {
        if (e.code === 'KeyF' || e.key === 'f') {
            e.preventDefault();
            handleFullscreenToggle();
        }
    });
</script>
</body>
</html>